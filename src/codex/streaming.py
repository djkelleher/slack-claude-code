"""Parser for Codex CLI stream-json output format."""

import json
import time
from dataclasses import dataclass
from typing import Any, Iterator, Optional

from loguru import logger

from src.claude.streaming import _concat_with_spacing
from src.config import config
from src.utils.tool_input_summary import format_tool_input_summary

# Maximum size for buffered incomplete JSON to prevent memory exhaustion
MAX_BUFFER_SIZE = 1024 * 1024  # 1MB

CODEX_TOOL_SUMMARY_RULES = {
    "read_file": {"type": "path", "keys": ["path", "file_path"]},
    "edit_file": {"type": "path", "keys": ["path", "file_path"]},
    "write_file": {"type": "path", "keys": ["path", "file_path"]},
    "shell": {"type": "cmd", "keys": ["command", "cmd"]},
    "run_command": {"type": "cmd", "keys": ["command", "cmd"]},
    "glob": {"type": "pattern", "keys": ["pattern"]},
    "find_files": {"type": "pattern", "keys": ["pattern"]},
    "grep": {"type": "pattern", "keys": ["pattern", "query"]},
    "search": {"type": "pattern", "keys": ["pattern", "query"]},
    "web_fetch": {"type": "url", "keys": ["url"]},
    "web_search": {"type": "text", "keys": ["query"]},
    "request_user_input": {"type": "first_question", "keys": ["questions"]},
}


@dataclass
class ToolActivity:
    """Structured representation of a tool invocation.

    Tracks the full lifecycle of a tool use from invocation to result.
    """

    id: str  # tool_use_id from Codex
    name: str  # Read, Edit, Write, Bash, etc.
    input: dict  # Full tool input parameters
    input_summary: str  # Short summary for inline display
    result: Optional[str] = None  # Result content (truncated for display)
    full_result: Optional[str] = None  # Full untruncated result
    is_error: bool = False
    duration_ms: Optional[int] = None
    started_at: Optional[float] = None  # time.monotonic() for duration calculation
    timestamp: Optional[float] = None  # time.time() wall-clock for display

    @classmethod
    def create_input_summary(cls, name: str, input_dict: dict) -> str:
        """Create a short summary of tool input for inline display."""
        display = config.timeouts.display
        return format_tool_input_summary(name, input_dict, display, CODEX_TOOL_SUMMARY_RULES)


@dataclass
class StreamMessage:
    """Parsed message from Codex's stream-json output."""

    type: str  # init, assistant, user, result, error, tool_call, tool_result
    content: str = ""
    detailed_content: str = ""  # Full output with tool use details
    tool_activities: Optional[list[ToolActivity]] = None  # Structured tool data
    session_id: Optional[str] = None
    is_final: bool = False
    cost_usd: Optional[float] = None
    duration_ms: Optional[int] = None
    raw: dict = None

    def __post_init__(self):
        if self.raw is None:
            self.raw = {}
        if self.tool_activities is None:
            self.tool_activities = []


class StreamParser:
    """Parser for normalized Codex app-server stream events.

    The executor maps app-server JSON-RPC notifications into line-delimited event
    payloads consumed here (for example: thread.started, item.started/completed,
    request_user_input, turn.completed, turn.failed).
    """

    def __init__(self):
        self.buffer = ""
        self.session_id: Optional[str] = None
        self.accumulated_content = ""
        self.accumulated_detailed = ""
        # Track pending tool uses to link with results
        self.pending_tools: dict[str, ToolActivity] = {}  # tool_use_id -> ToolActivity

    def _append_assistant_content(self, content: str) -> None:
        """Append assistant text to accumulated output buffers."""
        if not content:
            return
        self.accumulated_content = _concat_with_spacing(self.accumulated_content, content)
        self.accumulated_detailed = _concat_with_spacing(self.accumulated_detailed, content)

    def _create_tool_call(
        self,
        tool_id: str,
        tool_name: str,
        tool_input: Any,
        raw_data: dict,
    ) -> StreamMessage:
        """Create a normalized tool-call StreamMessage."""
        tool_input = self._normalize_tool_input(tool_input)

        tool_activity = ToolActivity(
            id=tool_id,
            name=tool_name,
            input=tool_input,
            input_summary=ToolActivity.create_input_summary(tool_name, tool_input),
            started_at=time.monotonic(),
            timestamp=time.time(),
        )

        if tool_id in self.pending_tools:
            logger.warning(
                f"Tool ID collision detected: {tool_id} already tracked. "
                "This may indicate duplicate tool invocations."
            )
        self.pending_tools[tool_id] = tool_activity

        detailed_addition = f"\n\n[Tool: {tool_name}]\n"
        for key, value in tool_input.items():
            if isinstance(value, str) and len(value) > 100:
                value_preview = value[:100] + "..."
            else:
                value_preview = value
            detailed_addition += f"  {key}: {value_preview}\n"

        self.accumulated_detailed += detailed_addition

        return StreamMessage(
            type="tool_call",
            tool_activities=[tool_activity],
            session_id=self.session_id,
            raw=raw_data,
        )

    @staticmethod
    def _normalize_tool_input(tool_input: Any) -> dict:
        """Normalize tool input payload into a dictionary."""
        if isinstance(tool_input, str):
            try:
                tool_input = json.loads(tool_input)
            except json.JSONDecodeError:
                return {"raw": tool_input}

        if isinstance(tool_input, dict):
            return tool_input

        if tool_input is None:
            return {}

        return {"raw": tool_input}

    def _create_tool_result(
        self,
        tool_use_id: str,
        content: str,
        is_error: bool,
        raw_data: dict,
    ) -> StreamMessage:
        """Create a normalized tool-result StreamMessage."""
        full_content = content or ""
        content_preview = full_content[:500] + "..." if len(full_content) > 500 else full_content
        tool_activities = []

        if tool_use_id in self.pending_tools:
            tool_activity = self.pending_tools.pop(tool_use_id)
            tool_activity.result = content_preview
            tool_activity.full_result = full_content
            tool_activity.is_error = is_error
            if tool_activity.started_at:
                tool_activity.duration_ms = int(
                    (time.monotonic() - tool_activity.started_at) * 1000
                )
            tool_activities.append(tool_activity)
        else:
            tool_activity = ToolActivity(
                id=tool_use_id,
                name="unknown",
                input={},
                input_summary="",
                result=content_preview,
                full_result=full_content,
                is_error=is_error,
            )
            tool_activities.append(tool_activity)

        status = "ERROR" if is_error else "SUCCESS"
        detailed_addition = f"\n\n[Tool Result: {status}]\n{content_preview}\n"
        self.accumulated_detailed += detailed_addition

        return StreamMessage(
            type="tool_result",
            detailed_content=detailed_addition,
            tool_activities=tool_activities,
            session_id=self.session_id,
            raw=raw_data,
        )

    def _create_result_message(self, raw_data: dict) -> StreamMessage:
        """Create a normalized final-result StreamMessage."""
        self.pending_tools.clear()
        return StreamMessage(
            type="result",
            content=self.accumulated_content,
            detailed_content=self.accumulated_detailed,
            session_id=raw_data.get("session_id", self.session_id),
            is_final=True,
            cost_usd=raw_data.get("cost_usd", raw_data.get("usage", {}).get("cost")),
            duration_ms=raw_data.get("duration_ms", raw_data.get("duration")),
            raw=raw_data,
        )

    def parse_line(self, line: str) -> Optional[StreamMessage]:
        """Parse a single line of stream-json output."""
        line = line.strip()
        if not line:
            return None

        try:
            data = json.loads(line)
        except json.JSONDecodeError:
            # Might be partial JSON, buffer it
            self.buffer += line
            # Prevent unbounded buffer growth
            if len(self.buffer) > MAX_BUFFER_SIZE:
                logger.error(
                    f"Stream buffer overflow ({len(self.buffer)} bytes exceeds {MAX_BUFFER_SIZE} limit). "
                    "This may indicate a malformed JSON stream or extremely large output. Resetting buffer."
                )
                self.buffer = ""
                return StreamMessage(
                    type="error",
                    content=f"Stream buffer overflow: JSON chunk exceeded {MAX_BUFFER_SIZE // 1024}KB limit",
                    raw={},
                )
            try:
                data = json.loads(self.buffer)
                self.buffer = ""
            except json.JSONDecodeError:
                return None

        # Determine event type - Codex uses different event structure
        event_type = data.get("type", data.get("event", "unknown"))

        if event_type == "thread.started":
            # New stream format: thread id acts as session id.
            self.session_id = data.get("thread_id", self.session_id)
            return StreamMessage(
                type="init",
                session_id=self.session_id,
                raw=data,
            )

        elif event_type == "turn.started":
            return StreamMessage(type="turn_started", session_id=self.session_id, raw=data)

        elif event_type == "item.started":
            # New stream format: item lifecycle events.
            item = data.get("item", {})
            item_type = item.get("type")
            if item_type == "command_execution":
                tool_id = str(item.get("id", "unknown"))
                command = item.get("command", "")
                return self._create_tool_call(
                    tool_id=tool_id,
                    tool_name="run_command",
                    tool_input={"command": command},
                    raw_data=data,
                )
            return StreamMessage(type="item_started", session_id=self.session_id, raw=data)

        elif event_type == "item.completed":
            # New stream format: completed items include assistant messages and command results.
            item = data.get("item", {})
            item_type = item.get("type")
            if item_type == "agent_message":
                content = item.get("text", "")
                self._append_assistant_content(content)
                return StreamMessage(
                    type="assistant",
                    content=content,
                    detailed_content=content,
                    session_id=self.session_id,
                    raw=data,
                )
            if item_type == "command_execution":
                tool_id = str(item.get("id", "unknown"))
                command_output = item.get("aggregated_output", item.get("output", ""))
                exit_code = item.get("exit_code")
                status = str(item.get("status", "")).lower()
                item_error = item.get("error")
                is_error = (
                    exit_code not in (0, None)
                    or status in {"failed", "error", "cancelled"}
                    or bool(item_error)
                )
                if not command_output and item_error:
                    command_output = (
                        item_error.get("message", str(item_error))
                        if isinstance(item_error, dict)
                        else str(item_error)
                    )
                return self._create_tool_result(
                    tool_use_id=tool_id,
                    content=command_output,
                    is_error=is_error,
                    raw_data=data,
                )
            return StreamMessage(type="item_completed", session_id=self.session_id, raw=data)

        elif event_type == "request_user_input":
            # App-server stream format: request for structured user input.
            call_id = str(data.get("call_id", data.get("id", "request_user_input")))
            questions = data.get("questions", [])
            return self._create_tool_call(
                tool_id=call_id,
                tool_name="request_user_input",
                tool_input={"questions": questions},
                raw_data=data,
            )

        elif event_type == "turn.completed":
            return self._create_result_message(data)

        elif event_type == "turn.failed":
            error_obj = data.get("error", {})
            error_msg = error_obj.get("message") if isinstance(error_obj, dict) else str(error_obj)
            return StreamMessage(
                type="error",
                content=str(error_msg or "Codex turn failed"),
                session_id=self.session_id,
                is_final=True,
                raw=data,
            )

        elif event_type == "assistant":
            # Synthetic assistant delta event emitted by executor.
            content = data.get("content", data.get("text", ""))
            self._append_assistant_content(str(content))

            return StreamMessage(
                type="assistant",
                content=str(content),
                detailed_content=str(content),
                session_id=self.session_id,
                raw=data,
            )

        elif event_type == "tool_result":
            # Synthetic tool_result event emitted by executor.
            tool_use_id = data.get("tool_use_id", data.get("id", "unknown"))
            content = data.get("content", data.get("output", data.get("result", "")))
            is_error = data.get("is_error", data.get("error", False))

            if isinstance(is_error, str):
                is_error = is_error.lower() == "true"

            # Get full content as string
            if isinstance(content, str):
                full_content = content
            elif isinstance(content, list):
                full_content = ""
                for item in content:
                    if isinstance(item, dict) and item.get("type") == "text":
                        full_content += item.get("text", "")
                    elif isinstance(item, str):
                        full_content += item
            else:
                full_content = str(content) if content else ""

            return self._create_tool_result(
                tool_use_id=tool_use_id,
                content=full_content,
                is_error=is_error,
                raw_data=data,
            )

        elif event_type == "error":
            error_msg = data.get("error", {})
            if isinstance(error_msg, dict):
                error_msg = error_msg.get("message", str(error_msg))
            return StreamMessage(
                type="error",
                content=str(error_msg),
                is_final=True,
                raw=data,
            )

        # Handle any other message type
        return StreamMessage(type=event_type, raw=data)

    def parse_stream(self, stream: Iterator[str]) -> Iterator[StreamMessage]:
        """Parse a stream of lines."""
        for line in stream:
            msg = self.parse_line(line)
            if msg:
                yield msg

    def reset(self):
        """Reset parser state."""
        self.buffer = ""
        self.session_id = None
        self.accumulated_content = ""
        self.accumulated_detailed = ""
        self.pending_tools.clear()
